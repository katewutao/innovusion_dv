# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'userpage.ui'
#
# Created by: PyQt5 UI code generator 5.15.4
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.
import os
import sys
import time
from PyQt5 import QtCore, QtWidgets, QtGui
from PyQt5.QtGui import *
from PyQt5.QtWidgets import *
from PyQt5.QtCore import *
import userpage
import subprocess
import re,threading
import platform
import datetime
import traceback
import inspect
import pandas as pd
import shutil,json,importlib
from auto_update_sdk import down_sdk
import ctypes,inspect
 
 
def _async_raise(tid, exctype):
    """raises the exception, performs cleanup if needed"""
    tid = ctypes.c_long(tid)
    if not inspect.isclass(exctype):
        exctype = type(exctype)
    res = ctypes.pythonapi.PyThreadState_SetAsyncExc(tid, ctypes.py_object(exctype))
    if res == 0:
        raise ValueError("invalid thread id")
    elif res != 1:
        # """if it returns a number greater than one, you're in trouble,
        # and you should call it again with exc=NULL to revert the effect"""
        ctypes.pythonapi.PyThreadState_SetAsyncExc(tid, None)
        raise SystemError("PyThreadState_SetAsyncExc failed")
 
 
def stop_thread(thread):
    _async_raise(thread.ident, SystemExit)
    

def handle_exceptions(func):
    def wrapper(*args, **kwargs):
        try:
            sig = inspect.signature(func)
            num_args = len(sig.parameters)
            if num_args == len(args):
                result = func(*args)
            else:
                instance = args[0]
                result = func(instance, **kwargs)
            return result
        except Exception as e:
            traceback.print_exc()
            print(f"Error occurred while executing {func.__name__}: {e}")
            return None
    return wrapper

def get_current_date():
    start_time=f"{datetime.datetime.now()}"
    ret=re.findall("\d+",start_time)
    start_time=f"{ret[0].zfill(4)}{ret[1].zfill(2)}{ret[2].zfill(2)}T{ret[3].zfill(2)}{ret[4].zfill(2)}{ret[5].zfill(2)}"
    return start_time

log_file="python_"+get_current_date()+".log"
rewrite_print=print
def print(*arg,**kwarg):
    rewrite_print(*arg,**kwarg)
    rewrite_print(*arg,**kwarg,file=open(log_file,"a"))

def downlog(ip,log_path,time_path):
    save_path=os.path.join(log_path,ip.replace('.','_'))
    save_path=os.path.join(save_path,time_path)
    os.makedirs(save_path)
    command1=f"sshpass -p 4920lidar scp -rp root@{ip}:/tmp '{save_path}'"
    command2=f"sshpass -p 4920lidar scp -rp root@{ip}:/mnt '{save_path}'"
    cmd1=subprocess.Popen(command1,shell=True)
    cmd2=subprocess.Popen(command2,shell=True)
    cmd1.wait()
    cmd2.wait()

def ping(ip,interval_time):
    command=f'ping -c 1 -W 0.15 {ip}'
    cmd=subprocess.Popen('exec '+command,shell=True,stdout=subprocess.PIPE,stderr=subprocess.PIPE)
    time.sleep(interval_time)
    if cmd.poll() is not None:
        res=cmd.stdout.read().decode('utf-8')
    else:
        res=''
    cmd.kill()
    if "1 received" in res:
        return 1
    else:
        return 0


def list_in_str(key_list,str1):
    for key in key_list:
        if key in str1:
            return True
    return False

def init_power():
    import shutil
    cmd=os.popen("lsusb")
    res=cmd.read()
    if os.path.exists("power.py"):
        os.remove("power.py")
    if list_in_str(["FT232","0403:6001","067b:23c3"],res):
        shutil.copyfile(os.path.join(os.getcwd(),"power_DH.py"),os.path.join(os.getcwd(),"power.py"))
        return True 
    elif list_in_str(["HL-340","PL2303","1a86:7523"],res):
        shutil.copyfile(os.path.join(os.getcwd(),"power_PY.py"),os.path.join(os.getcwd(),"power.py"))
        return True
    print("power is not PY or DH")
    return False
    
    
def ping_sure(ip,interval_time):
    flag=ping(ip,interval_time)
    while flag==0:
        print(f'[{datetime.datetime.now()}]please connect lidar {ip}')
        flag=ping(ip,interval_time)
    print(f'[{datetime.datetime.now()}]lidar {ip} has connected')    
    
def get_promission(ip,time_out):
    if 'linux' in sys.platform:
        import pexpect as pect
    else:
        import wexpect as pect
    child = pect.spawn(f'ssh root@{ip}',timeout=time_out)
    try:
        child.expect('yes',timeout=3)
        child.sendline('yes')
    except:
        pass
    child.expect('password')
    child.sendline('4920lidar')
    child.close()


def get_circle_time(dict_config):
    times=[]
    for key in dict_config.keys():
        temp_times=re.findall("(\d+\.?\d*):(\d+\.?\d*):?(\d+\.?\d*)?",key)
        for i in range(len(temp_times)):
            temp_times[i]=list(temp_times[i])
            for j in range(len(temp_times[i])):
                if j!=2:
                    temp_times[i][j]=float(temp_times[i][j])*60
                else:
                    if temp_times[i][j]!="":
                        temp_times[i][j]=float(temp_times[i][j])
                    else:
                        temp_times[i][j]=14
        times+=temp_times*dict_config[key]
    return times


def set_can(ip):
    command=f'echo "dsp_boot_from can" | nc -nv {ip} 8001 -w1'
    os.system(command)
    
def cancle_can(ip_list):
    os.system("python3 ./power.py")
    print(f"{datetime.datetime.now()}:start set lidar power mode")
    subprocess.Popen(f'exec python3 usbcanfd_controler.py',shell=True)
    for ip in ip_list:
        ping_sure(ip,0.5)
        command=f'echo "dsp_boot_from power" | nc -nv {ip} 8001 -w1'
        os.system(command)
    os.system("ps -ef|grep usbcanfd_controler.py|grep -v grep|awk -F ' ' '{print $2}'|xargs kill -9")
    
def is_empty_folder(path):
    for _,_,files in os.walk(path):
        if len(files)!=0:
            return False
    return True


def rm_empty_folder(path):
    for root,_,_ in os.walk(path):
        if is_empty_folder(root):
            try:
                shutil.rmtree(root)
            except:
                pass

def get_time():
    times_now=time.strftime('%Y.%m.%d %H:%M:%S ',time.localtime(time.time()))
    res=times_now.strip().replace(':', '_').replace('.', '_').replace(' ', '_')
    return res




class one_lidar_record_thread(QThread):
    sigout_set_tbw_value = pyqtSignal(list,int)
    
    def __init__(self,ip,interval,record_folder,record_header,row_idx,record_func):
        super(one_lidar_record_thread,self).__init__()
        self.ip=ip
        self.interval=interval
        self.record_folder=record_folder
        self.row_idx=row_idx
        self.record_header=record_header
        self.record_func=record_func 
    

    def get_customerid(self):
        import socket
        customerid = 'null'
        command = 'mfg_rd "CustomerSN"\n'
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        s.connect((self.ip, 8002))
        s.settimeout(1)
        s.sendall(command.encode())
        try:
            data=s.recv(1024)
            lst = data.decode('ascii').split('\n')
            for s in lst:
                ret=re.search('CustomerSN.*?:\s*[\'|"](.+)[\'|"]',s)
                if ret:
                    customerid=ret.group(1)
                    break
        except Exception as e:
            print(e)
            customerid=self.get_customerid()
        return customerid 


    def get_sn(self):
        command=f"curl {self.ip}:8010/command/?get_sn"
        cmd = subprocess.Popen(command, shell=True,
                            stdout=subprocess.PIPE, stderr=subprocess.PIPE,universal_newlines=True)
        
        res=cmd.communicate()
        SN=res[0]
        if SN=="":
            return self.get_sn()
        return SN 

    def csv_write(self,file, lis):
        if not os.path.exists(file):
            str1 = ""
        else:
            str1 = '\n'
        for i in range(len(lis)):
            str1+=f'{lis[i]},'
        str1=str1[:-1]
        with open(file, 'a', newline='\n') as f:
            f.write(str1)

    @handle_exceptions
    def run(self):
        while True:
            if ping(self.ip,1):
                break
        ip_name=self.ip.replace('.', '_')
        save_log=os.path.join(self.record_folder,f"testlog_{ip_name}.txt")
        save_csv=os.path.join(self.record_folder,f"record_{ip_name}.csv")
        power_csv=os.path.join(self.record_folder,'pow_status.csv')
        if not os.path.exists(save_csv):
            file = open(save_csv, 'w', newline='\n')
            file.write(self.record_header)
            file.close()
        SN=self.get_sn()
        CustomerSN=self.get_customerid()
        while True:
            t=time.time()
            temp=self.record_func(self.ip,save_log,SN,CustomerSN,power_csv)
            if isinstance(temp,type(None)):
                continue
            self.csv_write(save_csv, temp)
            self.sigout_set_tbw_value.emit(temp,self.row_idx)
            sleep_time=self.interval-time.time()+t
            if sleep_time>0:
                time.sleep(sleep_time)
        
    def stop(self):
        self.terminate()



class TestMain(QThread):
    sigout_test_finish = pyqtSignal(str)
    def __init__(self,ip_list,record_folder,record_header,times,set_table_value,csv_write_func,record_func,txt_record_interval,txt_off_counter,txt_timeout,cb_lidar_mode):
        super(TestMain,self).__init__()
        self.csv_write_func=csv_write_func
        self.txt_record_interval=txt_record_interval
        self.cb_lidar_mode=cb_lidar_mode
        self.set_table_value=set_table_value
        self.save_folder=record_folder
        self.ip_list=ip_list
        self.txt_timeout=txt_timeout
        self.record_header=record_header
        self.txt_off_counter=txt_off_counter
        self.times=times
        self.record_func=record_func
    
    def one_cycle(self,power_one_time,ip_list,i,data_num_power_off,log_path):
        from power import Power
        while True:
            try:
                pow=Power()
                pow.set_voltage(power_one_time[2])
                df=pd.DataFrame([pow.PowerStatus()])
                if abs(df.iloc[0,0]-power_one_time[2])<0.5:
                    break
            except:
                print(f"{datetime.datetime.now()} set power voltage failed")
        print(f"[{str(datetime.datetime.now())}]: current circle {i}")
        t=time.time()
        time_path=get_time()
        if self.cb_lidar_mode.currentText()=="CAN":
            subprocess.Popen(f'exec python3 usbcanfd_controler.py',shell=True)
        else:
            while True:
                try:
                    pow=Power()
                    pow.power_on()
                    break
                except:
                    print(f"[{datetime.datetime.now()}]power on failed")
        self.records=[]
        for idx,ip in enumerate(ip_list):
            record_thread=one_lidar_record_thread(ip,float(self.txt_record_interval.text()),self.save_folder,self.record_header,idx,self.record_func)
            record_thread.sigout_set_tbw_value.connect(self.set_table_value)
            record_thread.start()
            self.records.append(record_thread)
        if power_one_time[0]>2:
            for ip_num,ip in enumerate(ip_list):
                raw_save_path=os.path.join(log_path,"raw",ip.replace(".","_"),time_path)
                subprocess.Popen(f'python3 capture_raw.py -i {ip} -s "{raw_save_path}" -f "{log_path}" -l {9100+ip_num} -ls {8100+ip_num} -lup {8600+ip_num}',shell=True)
            time.sleep(power_one_time[0]-2)
        threads=[]
        for ip in ip_list:
            thread=threading.Thread(target=downlog,args=(ip,log_path,time_path,))
            thread.start()
            threads.append(thread)
        for temp_thread in threads:
            temp_thread.join()
        if self.cb_lidar_mode.currentText()=="CAN":
            os.system("ps -ef|grep usbcanfd_controler.py|grep -v grep|awk '{print $2}'|xargs kill -9")
        else:
            while True:
                try:
                    pow=Power()
                    pow.power_off()
                    break
                except:
                    print(f"[{datetime.datetime.now()}]power off failed")
        os.system("ps -ef|grep capture_raw.py|grep -v grep|awk '{print $2}'|xargs kill -9")
        os.system("ps -ef|grep inno_pc_client|grep -v grep|awk '{print $2}'|xargs kill -9")
        print("start sleep")
        for record in self.records:
            record.stop()
        for i in range(data_num_power_off):
            for ip in ip_list:
                if self.cb_lidar_mode.currentText()=="CAN":
                    while True:
                        try:
                            pow = pd.read_csv(os.path.join(self.save_folder,'pow_status.csv'), header=None).values.tolist()
                            break
                        except:
                            pass
                    temp=[str(datetime.datetime.now())]+[-100]*(self.record_header.count(",")-2)+pow[0]
                else:
                    temp=[str(datetime.datetime.now())]+[-100]*(self.record_header.count(","))
                self.csv_write_func(os.path.join(self.save_folder,'record_'+ip.replace('.','_')+'.csv'),temp)
            t0=(power_one_time[0]+power_one_time[1]-(time.time()-t))/(data_num_power_off-i)
            if t0>0:
                time.sleep(t0)

    @handle_exceptions
    def run(self):
        os.system("ps -ef|grep inno_pc_client|grep -v grep|awk '{print $2}'|xargs kill -9")
        os.system("ps -ef|grep 'python3 power_client.py'|grep -v grep|awk '{print $2}'|xargs kill -9")
        if self.txt_record_interval.text().strip()=="":
            print("please input record interval time")
            return None
        if self.txt_off_counter.text().strip()=="":
            print("please input power off empty data number")
            return None
        print(f"[{datetime.datetime.now()}]get inno_pc_client permission")
        os.system('echo demo|sudo -S chmod 777 lidar_util/inno_pc_client')
        while not init_power():
            pass
        if not os.path.exists(self.save_folder):
            os.makedirs(self.save_folder)
        os.system("python3 ./power.py")
        for idx,ip in enumerate(self.ip_list):
            ping_sure(ip,0.5)
            try:
                down_sdk(ip)
            except:
                pass
            try:
                get_promission(ip,float(self.txt_timeout.text()))
                if self.cb_lidar_mode.currentText()=="CAN":
                    set_can(ip)
            except:
                pass
            record_file=os.path.join(self.save_folder,'record_'+ip.replace('.','_')+'.csv')
            if not os.path.exists(record_file):
                with open(record_file,"w",newline="\n") as f:
                    f.write(self.record_header)
        if self.cb_lidar_mode.currentText()=="CAN":
            os.system("python3 lib/set_usbcanfd_env.py demo")
        command=f'exec python3 power_client.py -s "{self.save_folder}"'
        self.cmd_pow=subprocess.Popen(command,stderr=subprocess.PIPE,shell=True)
        i=1
        for time_one in self.times:
            self.one_cycle(time_one,self.ip_list,i,int(self.txt_off_counter.text()),self.save_folder)
            i+=1 
        self.cmd_pow.kill()
        if self.cb_lidar_mode.currentText()=="CAN":
            cancle_can(self.ip_list)
        os.system("echo demo|sudo -S python3 ./power.py")
        import power
        pow=power.Power()
        pow.power_off()
        rm_empty_folder(self.save_folder)
        self.sigout_test_finish.emit("done")
        
    def stop(self):
        try:
            for record in self.records:
                try:
                    record.stop()
                except:
                    pass
        except:
            pass
        try:
            self.cmd_pow.kill()
        except:
            pass
        self.terminate()
        print(f"[{datetime.datetime.now()}]:Test has been stop")

class EmittingStream(QtCore.QObject):
    textWritten = QtCore.pyqtSignal(str)
    def write(self, text):
        self.textWritten.emit(str(text))

        
class MainCode(QMainWindow,userpage.Ui_MainWindow):
    
    def __init__(self):
        QMainWindow.__init__(self)
        userpage.Ui_MainWindow.__init__(self)
        self.setupUi(self)
        
        self.project_folder="./project"
        self.test_folder="./test_config"

        self.cb_project.currentIndexChanged.connect(self.project_changed)
        self.cb_test_name.currentIndexChanged.connect(self.test_name_changed)
        self.btn_start.clicked.connect(self.test_main)
        self.btn_cancle_can.clicked.connect(self.cancle_can_mode)
        self.btn_stop.clicked.connect(self.test_stop)
        self.init_select_item()
    
        
        IntValidator = QIntValidator(0,100000)
        DoubleValidator = QDoubleValidator(0,100000,3,notation=QtGui.QDoubleValidator.StandardNotation)
        self.txt_timeout.setValidator(DoubleValidator)
        self.txt_record_interval.setValidator(DoubleValidator)
        self.txt_off_counter.setValidator(IntValidator)
        
        sys.stdout = EmittingStream(textWritten=self.normalOutputWritten)
        sys.stderr = EmittingStream(textWritten=self.normalOutputWritten)

    def write(self, info):
        self.txt_log.insertPlainText(info)
        if len(info):
            self.txt_log.setText(info)
            QtWidgets.qApp.processEvents(
                QtCore.QEventLoop.ExcludeUserInputEvents | QtCore.QEventLoop.ExcludeSocketNotifiers)
            self.stdoutbak.write(info)

    def normalOutputWritten(self, text):
        self.txt_log.append(text.strip('\n'))
        self.cursor=self.txt_log.textCursor()
        self.txt_log.moveCursor(self.cursor.End) 
        QtWidgets.QApplication.processEvents()
    
    def init_table(self,row_counter,columns):
        for row_num in range(self.tbw_data.rowCount(),-1,-1):
            self.tbw_data.removeRow(row_num)
        self.tbw_data.setColumnCount(len(columns))
        for j in range(len(columns)):
            self.tbw_data.setHorizontalHeaderItem(j, QtWidgets.QTableWidgetItem())
            item = self.tbw_data.horizontalHeaderItem(j)
            item.setText(f"{columns[j]}")
        for i in range(row_counter):
            self.tbw_data.insertRow(i)
            for j in range(10):
                self.tbw_data.setItem(i,j,QtWidgets.QTableWidgetItem(f""))        
    
    def set_table_value(self,values,row_idx):
        for idx,value in enumerate(values):
            self.tbw_data.setItem(row_idx,idx,QtWidgets.QTableWidgetItem(f"{value}"))
    
    def init_select_item(self):
        self.cb_project.clear()
        self.cb_test_name.clear()
        
        for project in os.listdir(self.project_folder):
            ret=re.search("^(.+)\.py",project)
            if ret:
                self.cb_project.addItem(ret.group(1))
        for test_name in os.listdir(self.test_folder):  # may can be json file, but no explain
            ret=re.search("^(.+)\.py",test_name)
            if ret:
                self.cb_test_name.addItem(ret.group(1))
        self.test_name_changed()
        self.project_changed()
    
    @handle_exceptions
    def test_name_changed(self):
        if self.cb_test_name.currentText().strip()!="":
            mata_class=importlib.import_module(f"{self.test_folder.strip('.').strip('/')}.{self.cb_test_name.currentText()}")
            self.test_config=mata_class.config
            self.save_folder=self.cb_test_name.currentText()
            self.read_config()
        
    def project_changed(self):
        if self.cb_project.currentText().strip()!="":
            mata_class=importlib.import_module(f"{self.project_folder.strip('.').strip('/')}.{self.cb_project.currentText()}")
            self.record_header=mata_class.record_header
            self.csv_write_func=mata_class.csv_write
            self.record_func=mata_class.one_record
            self.read_config()

    def read_config(self):
        if getattr(self,"test_config",None):
            self.ip_list=self.test_config["lidar_ip"]
            self.times=get_circle_time(self.test_config["time_dict"])
            self.init_table(len(self.ip_list),self.record_header.split(","))
    
    @handle_exceptions
    def test_main(self):
        self.test=TestMain(self.ip_list,self.save_folder,self.record_header,self.times,self.set_table_value,self.csv_write_func,self.record_func,self.txt_record_interval,self.txt_off_counter,self.txt_timeout,self.cb_lidar_mode)
        self.test.sigout_test_finish.connect(self.test_finish)
        self.test.start()
        self.test_set_off()
    
    def test_finish(self,str1):
        self.test_set_on()
        print(f"[{datetime.datetime.now()}]:Test finished")
    
    def test_set_off(self):
        self.cb_lidar_mode.setEnabled(False)
        self.cb_project.setEnabled(False)
        self.cb_test_name.setEnabled(False)
        self.txt_off_counter.setEnabled(False)  #setReadOnly(True)
        self.txt_record_interval.setEnabled(False)
        self.txt_timeout.setEnabled(False)
        self.btn_start.setEnabled(False)
        self.btn_cancle_can.setEnabled(False)
        self.btn_stop.setEnabled(True)
    
    def test_set_on(self):
        self.cb_lidar_mode.setEnabled(True)
        self.cb_project.setEnabled(True)
        self.cb_test_name.setEnabled(True)
        self.txt_off_counter.setEnabled(True)  #setReadOnly(True)
        self.txt_record_interval.setEnabled(True)
        self.txt_timeout.setEnabled(True)
        self.btn_start.setEnabled(True)
        self.btn_cancle_can.setEnabled(True)
        self.btn_stop.setEnabled(False)
    
    def test_stop(self):
        self.test.stop()
        self.test_set_on()
    
    
    def cancle_can_mode(self):
        os.system("python3 lib/set_usbcanfd_env.py demo")
        cancle_can(self.ip_list)
    
        
    
        
if __name__ == '__main__':
    QGuiApplication.setAttribute(Qt.HighDpiScaleFactorRoundingPolicy.PassThrough)
    app = QtWidgets.QApplication(sys.argv)
    window = MainCode()
    window.show()
    sys.exit(app.exec_())
